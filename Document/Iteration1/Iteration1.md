# Diagramme de cas d'utilisation

```Mermaid
graph LR
    Joueur[üßç‚Äç‚ôÇÔ∏è Joueur] --- Nim([Jouer au jeu de Nim])
```

# Sc√©nario

## **UC : Jouer au jeu de Nim**
**P√©rim√®tre** : Le jeu <br>
**Niveau** : But utilisateur <br>
**Acteur principal** : Joueur<br>
**Pr√©-condition** : Aucune<br>
**Post-conditions** : Aucune

### Sc√©nario nominal

1. L'utilisateur lance le programme
2. Le syst√®me demande √† l'utilisateur le nombre de tas qu'il souhaite
3. L'utilisateur r√©pond √† la question
4. Le syst√®me enregistre le nombre de tas
5. Le syst√®me demande le nom du joueur 1
6. Le joueur 1 r√©pond
7. Le syst√®me enregistre le nom du joueur 1
8. Le syst√®me demande au joueur 2
9. Le joueur 2 r√©pond
10. Le syst√®me enregistre le nom du joueur 2
11. Le syst√®me affiche les tas ainsi que le nom du joueur qui doit jouer
12. Le joueur choisi dans quel tas il souhaite prendre un certain nombre d'allumette 
13. Le syst√®me v√©rifie si la partie est gagn√©
14. Le syst√®me affiche le vainqueur et demande si l'utilisateur souhaite refaire une partie ("y" or "n")
15. L'utilisateur r√©pond "y" ou "n"
16. Le syst√®me retourne au point 8 du sc√©nario nominal et incr√©ment le classement entre les deux joueur


### Extensions

4. a Le joueur r√©pond autre chose ou un nombre inf√©rieur √† 1
    1. Le syst√®me affiche un message d'erreur "le nombre de tas doit √™tre un entier sup√©rieur √† 1"
    2. Retour au point 2 du sc√©nario nominal

7. a L'utilisateur r√©pond √† la question avec une cha√Æne vide
    1. Le syst√®me affiche un message d'erreur "Le nom ne peut pas √™tre vide"
    2. Retour au point 5 du sc√©nario nominal

10. a L'utilisateur r√©pond √† la question avec une cha√Æne vide
    1. Le syst√®me affiche un message d'erreur "Le nom ne peut pas √™tre vide"
    2. Retour au point 8 du sc√©nario nominal

13. a Le joueur n'a pas entr√© une r√©ponse au format $m\ n$
    1. Le syst√®me affiche un message d'erreur "Le format de la r√©ponse doit √™tre $n\ m$"
    2. Retour au point 11 du sc√©nario nominal avec le m√™me joueur

13. b Le joueur a demand√© un tas qui n'existe pas
    1. Le syst√®me affiche un message d'erreur "Tas inexistant"
    2. Retour au point 11 du sc√©nario nominal avec le m√™me joueur

13. c Le joueur veut prendre un nombre d'allumette sup√©rieur au nombre contenue dans le tas
    1. Le syst√®me affiche un message d'erreur "Pas assez d'allumette dans ce tas"
    2. Retour au point 11 du sc√©nario nominal avec le m√™me joueur

13. d La partie n'est pas fini 
    1. Retour au point 11 du sc√©nario nominal avec l'autre joueur

16. a L'utilisateur √† r√©pondu autre chose que y ou n
    1. Le syst√®me affiche un message d'erreur "R√©pondre avec "y" ou "n""
    2. Retour au point 14 du sc√©nario nominal

16. b L'utilisateur √† choisi d‚Äôarr√™ter de jouer
    1. Le syst√®me affiche le classement entre les deux joueur
    2. Le syst√®me attend une action de l'utilisateur pour arr√™ter le programme

# Diagrammes de Classes

## Jeu de Nim (It√©ration 1)

```mermaid
classDiagram
    class main {

    }

    class Ihm {
        Scanner scanner

        + demanderNbTas() int
        + demanderNomJoueur(String numJoueur) String
        + demanderCoupNim(String nomJoueur) int[]
        + demanderJouerEncore() bool

        + afficherErreurNombreTas() void
        + afficherErreurNom() void
        + afficherErreurFormatNim() void
        + afficherErreurTasInexistant() void
        + afficherErreurNombreInsuffisant() void
        + afficherErreurRejouer() void
    }

    class ControleurJeuNim {
        int numJoueurCourant

        + ControleurJeuNim(Ihm ihm)
        + Jouer () void
        - commencerPartie() void
        - tourSuivant() int
        - retirerBatonnet(int m, int n, int j) bool
        - verifierFin() bool
    }

    class Joueur {
        String nom
        int nbVictoires

        + Joueur(String nom)
        + getNom() String
        + incrementeVictoires() void
        + getVictoires() int
    }

    class Tas {
        int nombreBatonnet

        + Tas (int nombreBatonnet)

        + retirerBatonnet(int x) bool
        + getNombre() int
        + estVide() bool
    }

    class Plateau {
        + Plateau (int nombreTas)
        + verifierFin() bool
        + getPlateau() int[]
    }

    Tas "1..n" --* "1" Plateau : lesTas
    ControleurJeuNim "1" <-- "1" Plateau
    ControleurJeuNim "1" <-- "1" Ihm
    ControleurJeuNim "1" <-- "2" Joueur : lesJoueurs
```

idTas ou avec une map idTas : Tas dans plateau ou avec une associations qualifi√©es


Dans la class ControleurJeuNim la m√©thode jouer est celle qui est appeler par le main √† voir ce qu'elle fait en r√©alit√© (peut √™tre l'initialisation du nb de tas et du nom des joueurs)

```java
public static void main(String[] args) {
    Ihm ihm = new Ihm();
    ControleurJeuNim controleurJeuNim=new ControleurJeuNim(ihm);
    controleurJeuNim.jouer();
}
```

Dans ControleurJeuNim la m√©thode retirerBatonnet(int m, int n, int j), renommer les variables en retirerBatonnet(int numTas, int nb, int j) et c'est quoi j ?

Dans la class Ihm la m√©thode demanderNomJoueur, elle demande pour un seul joueur ou les deux, perso , je penserait 1 seul pour le future avec le robot


Dans la class Ihm la m√©thode demanderCoupNim, je sais pas si on renvoie un tableau de int avec la colonne et le nombre, ou on renvoi directement la String, perso je ferait plus  le tableau de int

Il reste juste les associations entre les classes en pr√©cisant le sens de navigation mais je suis pas super chaud la dessus
